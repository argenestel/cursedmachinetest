import{cv as h,cw as k,cx as v,cy as L,cz as P,cA as R,cB as d,cC as b,cD as m,cE as g,cF as x,cG as S,cH as A,cI as D}from"./index-COQjmB9B.js";(function(){try{var r=typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},e=new Error().stack;e&&(r._sentryDebugIds=r._sentryDebugIds||{},r._sentryDebugIds[e]="00fd7e77-5385-4bbc-aba6-b6fa0f9a3627",r._sentryDebugIdIdentifier="sentry-dbid-00fd7e77-5385-4bbc-aba6-b6fa0f9a3627")}catch{}})();const $={inputs:[{name:"message",type:"string"}],name:"Error",type:"error"},M={inputs:[{name:"reason",type:"uint256"}],name:"Panic",type:"error"};function j(r){const{abi:e,data:a}=r,n=h(a,0,4);if(n==="0x")throw new k;const t=[...e||[],$,M].find(o=>o.type==="error"&&n===v(L(o)));if(!t)throw new P(n,{docsPath:"/docs/contract/decodeErrorResult"});return{abiItem:t,args:"inputs"in t&&t.inputs&&t.inputs.length>0?R(t.inputs,h(a,4)):void 0,errorName:t.name}}const p=(r,e,a)=>JSON.stringify(r,(n,s)=>{const t=typeof s=="bigint"?s.toString():s;return typeof e=="function"?e(n,t):t},a);class w extends d{constructor({body:e,details:a,headers:n,status:s,url:t}){super("HTTP request failed.",{details:a,metaMessages:[s&&`Status: ${s}`,`URL: ${b(t)}`,e&&`Request body: ${p(e)}`].filter(Boolean)}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"HttpRequestError"}),Object.defineProperty(this,"body",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"headers",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"status",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"url",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.body=e,this.headers=n,this.status=s,this.url=t}}class I extends d{constructor({callbackSelector:e,cause:a,data:n,extraData:s,sender:t,urls:o}){super(a.shortMessage||"An error occurred while fetching for an offchain result.",{cause:a,metaMessages:[...a.metaMessages||[],a.metaMessages?.length?"":[],"Offchain Gateway Call:",o&&["  Gateway URL(s):",...o.map(u=>`    ${b(u)}`)],`  Sender: ${t}`,`  Data: ${n}`,`  Callback selector: ${e}`,`  Extra data: ${s}`].flat()}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"OffchainLookupError"})}}class q extends d{constructor({result:e,url:a}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${b(a)}`,`Response: ${p(e)}`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"OffchainLookupResponseMalformedError"})}}class C extends d{constructor({sender:e,to:a}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${a}`,`OffchainLookup sender address: ${e}`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"OffchainLookupSenderMismatchError"})}}function T(r,e){if(!m(r,{strict:!1}))throw new g({address:r});if(!m(e,{strict:!1}))throw new g({address:e});return r.toLowerCase()===e.toLowerCase()}const F="0x556f1830",_={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function N(r,{blockNumber:e,blockTag:a,data:n,to:s}){const{args:t}=j({data:n,abi:[_]}),[o,u,i,c,y]=t,{ccipRead:f}=r,E=f&&typeof f?.request=="function"?f.request:G;try{if(!T(s,o))throw new C({sender:o,to:s});const l=await E({data:i,sender:o,urls:u}),{data:O}=await x(r,{blockNumber:e,blockTag:a,data:S([c,A([{type:"bytes"},{type:"bytes"}],[l,y])]),to:s});return O}catch(l){throw new I({callbackSelector:c,cause:l,data:n,extraData:y,sender:o,urls:u})}}async function G({data:r,sender:e,urls:a}){let n=new Error("An unknown error occurred.");for(let s=0;s<a.length;s++){const t=a[s],o=t.includes("{data}")?"GET":"POST",u=o==="POST"?{data:r,sender:e}:void 0;try{const i=await fetch(t.replace("{sender}",e).replace("{data}",r),{body:JSON.stringify(u),method:o});let c;if(i.headers.get("Content-Type")?.startsWith("application/json")?c=(await i.json()).data:c=await i.text(),!i.ok){n=new w({body:u,details:c?.error?p(c.error):i.statusText,headers:i.headers,status:i.status,url:t});continue}if(!D(c)){n=new q({result:c,url:t});continue}return c}catch(i){n=new w({body:u,details:i.message,url:t})}}throw n}export{G as ccipRequest,N as offchainLookup,_ as offchainLookupAbiItem,F as offchainLookupSignature};
//# sourceMappingURL=ccip-CraVrzbq.js.map
