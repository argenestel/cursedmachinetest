import{cj as l,ck as h,cl as b,cm as w,cn as k,co as O,cp as E,cq as L,cr as y,cs as x}from"./index-COQjmB9B.js";(function(){try{var t=typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},a=new Error().stack;a&&(t._sentryDebugIds=t._sentryDebugIds||{},t._sentryDebugIds[a]="852785e0-19e7-4464-ad9c-c7f3c9ff5d4a",t._sentryDebugIdIdentifier="sentry-dbid-852785e0-19e7-4464-ad9c-c7f3c9ff5d4a")}catch{}})();class R extends l{constructor({callbackSelector:a,cause:e,data:o,extraData:c,sender:i,urls:s}){super(e.shortMessage||"An error occurred while fetching for an offchain result.",{cause:e,metaMessages:[...e.metaMessages||[],e.metaMessages?.length?"":[],"Offchain Gateway Call:",s&&["  Gateway URL(s):",...s.map(d=>`    ${h(d)}`)],`  Sender: ${i}`,`  Data: ${o}`,`  Callback selector: ${a}`,`  Extra data: ${c}`].flat()}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"OffchainLookupError"})}}class M extends l{constructor({result:a,url:e}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${h(e)}`,`Response: ${b(a)}`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"OffchainLookupResponseMalformedError"})}}class D extends l{constructor({sender:a,to:e}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${e}`,`OffchainLookup sender address: ${a}`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"OffchainLookupSenderMismatchError"})}}const j="0x556f1830",$={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function v(t,{blockNumber:a,blockTag:e,data:o,to:c}){const{args:i}=w({data:o,abi:[$]}),[s,d,r,n,p]=i,{ccipRead:u}=t,m=u&&typeof u?.request=="function"?u.request:S;try{if(!k(c,s))throw new D({sender:s,to:c});const f=await m({data:r,sender:s,urls:d}),{data:g}=await O(t,{blockNumber:a,blockTag:e,data:E([n,L([{type:"bytes"},{type:"bytes"}],[f,p])]),to:c});return g}catch(f){throw new R({callbackSelector:n,cause:f,data:o,extraData:p,sender:s,urls:d})}}async function S({data:t,sender:a,urls:e}){let o=new Error("An unknown error occurred.");for(let c=0;c<e.length;c++){const i=e[c],s=i.includes("{data}")?"GET":"POST",d=s==="POST"?{data:t,sender:a}:void 0;try{const r=await fetch(i.replace("{sender}",a).replace("{data}",t),{body:JSON.stringify(d),method:s});let n;if(r.headers.get("Content-Type")?.startsWith("application/json")?n=(await r.json()).data:n=await r.text(),!r.ok){o=new y({body:d,details:n?.error?b(n.error):r.statusText,headers:r.headers,status:r.status,url:i});continue}if(!x(n)){o=new M({result:n,url:i});continue}return n}catch(r){o=new y({body:d,details:r.message,url:i})}}throw o}export{S as ccipRequest,v as offchainLookup,$ as offchainLookupAbiItem,j as offchainLookupSignature};
//# sourceMappingURL=ccip-C45Okdzk.js.map
